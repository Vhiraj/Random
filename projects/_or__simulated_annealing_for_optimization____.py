This project provides a complete and production-ready Python implementation of Dijkstra's Algorithm for finding the shortest paths in a weighted, directed graph.

Dijkstra's Algorithm is a popular greedy algorithm that solves the single-source shortest path problem for a graph with non-negative edge weights. It works by iteratively visiting the unvisited node with the smallest known distance from the source node, updating the distances of its neighbors, and marking it as visited. This process continues until all reachable nodes have been visited.

The project is structured into three main components:
1.  **`Graph` class**: Represents the graph using an adjacency list. It supports adding nodes and weighted, directed edges, and includes basic validation for non-negative edge weights.
2.  **`dijkstra` function**: The core algorithm implementation. It takes a `Graph` object and a starting node, returning a dictionary of shortest distances from the start node to all other nodes, and another dictionary for predecessors to reconstruct the paths. It leverages a min-heap (priority queue) for efficient node selection.
3.  **`reconstruct_path` function**: A utility function to build the actual shortest path as a list of nodes, given the `predecessors` information generated by Dijkstra's.

The code adheres to best practices, including comprehensive docstrings, type hinting, clear variable names, and error handling. An `if __name__ == "__main__":` block provides multiple detailed examples demonstrating how to use the `Graph` class and the Dijkstra's functions, covering various scenarios like basic graphs, disconnected components, and error cases.

```python
import heapq
import math

# This Python project implements Dijkstra's Algorithm to find the shortest path
# between a starting node and all other nodes in a weighted, directed graph.
#
# Dijkstra's Algorithm is a popular greedy algorithm that solves the single-source
# shortest path problem for a graph with non-negative edge weights. It works by
# iteratively visiting the unvisited node with the smallest known distance from
# the source node, updating the distances of its neighbors, and marking it as visited.
# This process continues until all reachable nodes have been visited.
#
# The project includes:
# 1. A `Graph` class to represent the graph using an adjacency list. It supports
#    adding nodes and weighted, directed edges.
# 2. A `dijkstra` function that takes a Graph object and a starting node, and
#    returns two dictionaries: one with the shortest distances from the start node
#    to all other nodes, and another with predecessors to reconstruct the path.
# 3. A `reconstruct_path` function to build the actual shortest path given the
#    predecessor information.
# 4. An example usage block (`if __name__ == "__main__":`) demonstrating how to
#    create a graph, run Dijkstra's, and print the results for various paths.
#
# This code is designed to be production-ready with clear structure, comments,
# docstrings, and type hints for improved readability and maintainability.


class Graph:
    """
    Represents a directed, weighted graph using an adjacency list.

    Attributes:
        nodes (set): A set of all nodes in the graph.
        adj (dict): An adjacency list where keys are nodes and values are
                    dictionaries of neighbors and their corresponding edge weights.
                    e.g., { 'A': {'B': 1, 'C': 4}, 'B': {'D': 2} }
    """

    def __init__(self):
        """Initializes an empty graph."""
        self.nodes = set()
        self.adj = {}

    def add_node(self, node: str) -> None:
        """
        Adds a single node to the graph.

        Args:
            node (str): The name/identifier of the node to add.
        """
        self.nodes.add(node)
        if node not in self.adj:
            self.adj[node] = {}

    def add_edge(self, u: str, v: str, weight: float) -> None:
        """
        Adds a directed, weighted edge from node `u` to node `v`.
        If nodes `u` or `v` do not exist, they are added to the graph first.

        Args:
            u (str): The starting node of the edge.
            v (str): The ending node of the edge.
            weight (float): The weight (cost) of the edge. Must be non-negative.

        Raises:
            ValueError: If the edge weight is negative.
        """
        if weight < 0:
            raise ValueError("Edge weights cannot be negative for Dijkstra's Algorithm.")

        # Ensure both nodes exist in the graph
        self.add_node(u)
        self.add_node(v)

        self.adj[u][v] = weight

    def get_neighbors(self, node: str) -> dict[str, float]:
        """
        Returns a dictionary of neighbors and their edge weights for a given node.

        Args:
            node (str): The node whose neighbors are to be retrieved.

        Returns:
            dict: A dictionary where keys are neighbor nodes and values are edge weights.
                  Returns an empty dictionary if the node has no neighbors or doesn't exist.
        """
        return self.adj.get(node, {})


def dijkstra(graph: Graph, start_node: str) -> tuple[dict[str, float], dict[str, str | None]]:
    """
    Implements Dijkstra's algorithm to find the shortest paths from a start node
    to all other reachable nodes in a weighted graph.

    Args:
        graph (Graph): The graph object to run the algorithm on.
        start_node (str): The node from which to start finding shortest paths.

    Returns:
        tuple[dict[str, float], dict[str, str | None]]: A tuple containing two dictionaries:
            - `distances`: A dictionary where keys are nodes and values are the
                           shortest distances from `start_node` to that node.
                           `math.inf` if a node is unreachable.
            - `predecessors`: A dictionary where keys are nodes and values are the
                              preceding node in the shortest path from `start_node`.
                              `None` for the start node or unreachable nodes.

    Raises:
        ValueError: If the `start_node` is not found in the graph.
    """
    if start_node not in graph.nodes:
        raise ValueError(f"Start node '{start_node}' not found in the graph.")

    # Initialize distances and predecessors for all nodes
    distances: dict[str, float] = {node: math.inf for node in graph.nodes}
    predecessors: dict[str, str | None] = {node: None for node in graph.nodes}
    distances[start_node] = 0

    # Priority queue to store (distance, node) tuples.
    # Uses a min-heap to efficiently retrieve the node with the smallest distance.
    priority_queue: list[tuple[float, str]] = [(0, start_node)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        # If we've already found a shorter path to current_node, skip this one
        if current_distance > distances[current_node]:
            continue

        # Explore neighbors
        for neighbor, weight in graph.get_neighbors(current_node).items():
            distance = current_distance + weight

            # If a shorter path to neighbor is found
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances, predecessors


def reconstruct_path(
    predecessors: dict[str, str | None], start_node: str, target_node: str
) -> list[str] | None:
    """
    Reconstructs the shortest path from the start node to the target node
    using the predecessors dictionary generated by Dijkstra's algorithm.

    Args:
        predecessors (dict[str, str | None]): The dictionary of predecessors.
        start_node (str): The starting node of the overall path.
        target_node (str): The target node for which to reconstruct the path.

    Returns:
        list[str] | None: A list of nodes representing the shortest path from
                          `start_node` to `target_node`. Returns `None` if
                          the target node is unreachable from the start node
                          (or if `target_node` was not part of the Dijkstra run).
    """
    if target_node not in predecessors:
        # This implies target_node was not part of the graph when Dijkstra was run
        # or it was somehow filtered out.
        print(f"Warning: Target node '{target_node}' not found in the predecessors map. "
              "It might not exist or was unreachable in the original graph context.")
        return None

    path: list[str] = []
    current_node: str | None = target_node

    # Backtrack from target to start using predecessors
    while current_node is not None and current_node != start_node:
        path.append(current_node)
        current_node = predecessors.get(current_node)

    # If the start node was successfully reached, add it and reverse the path
    if current_node == start_node:
        path.append(start_node)
        return path[::-1]  # Reverse to get path from start to target
    else:
        # This happens if target_node is unreachable from start_node
        # (current_node became None before reaching start_node)
        return None


if __name__ == "__main__":
    print("--- Dijkstra's Algorithm for Shortest Path ---")

    # --- Example 1: Basic Graph ---
    print("\n--- Example 1: Basic Graph ---")
    graph1 = Graph()
    graph1.add_edge("A", "B", 4)
    graph1.add_edge("A", "C", 2)
    graph1.add_edge("B", "E", 3)
    graph1.add_edge("C", "D", 2)
    graph1.add_edge("C", "F", 4)
    graph1.add_edge("D", "E", 3)
    graph1.add_edge("D", "F", 1)
    graph1.add_edge("E", "G", 2)
    graph1.add_edge("F", "G", 1)

    start_node1 = "A"
    print(f"Graph nodes: {sorted(list(graph1.nodes))}")
    print(f"Starting Dijkstra from node: {start_node1}")

    distances1, predecessors1 = dijkstra(graph1, start_node1)

    print("\nShortest Distances from 'A':")
    for node, dist in sorted(distances1.items()):
        print(f"  To {node}: {dist if dist != math.inf else 'Unreachable'}")

    print("\nShortest Paths from 'A':")
    # Test cases including reachable, unreachable, self, and non-existent nodes
    paths_to_check = ["E", "G", "F", "C", "A", "H"] 
    for target in paths_to_check:
        if target not in graph1.nodes:
            print(f"  A -> {target}: Target node '{target}' not in graph.")
            continue # Skip to next target

        path = reconstruct_path(predecessors1, start_node1, target)
        if path:
            print(f"  A -> {target}: {' -> '.join(path)} (Distance: {distances1.get(target, 'N/A')})")
        else:
            # If path is None, it means the target node is genuinely unreachable
            print(f"  A -> {target}: Unreachable. (Distance: {distances1.get(target, 'N/A')})")


    # --- Example 2: Graph with Disconnected Components ---
    print("\n--- Example 2: Graph with Disconnected Components ---")
    graph2 = Graph()
    graph2.add_edge("X", "Y", 1)
    graph2.add_edge("Y", "Z", 1)
    graph2.add_edge("P", "Q", 5) # Disconnected component

    start_node2 = "X"
    print(f"Graph nodes: {sorted(list(graph2.nodes))}")
    print(f"Starting Dijkstra from node: {start_node2}")

    distances2, predecessors2 = dijkstra(graph2, start_node2)

    print("\nShortest Distances from 'X':")
    for node, dist in sorted(distances2.items()):
        print(f"  To {node}: {dist if dist != math.inf else 'Unreachable'}")

    print("\nShortest Paths from 'X':")
    paths_to_check2 = ["Y", "Z", "P", "Q"]
    for target in paths_to_check2:
        if target not in graph2.nodes:
            print(f"  X -> {target}: Target node '{target}' not in graph.")
            continue

        path = reconstruct_path(predecessors2, start_node2, target)
        if path:
            print(f"  X -> {target}: {' -> '.join(path)} (Distance: {distances2.get(target, 'N/A')})")
        else:
            print(f"  X -> {target}: Unreachable. (Distance: {distances2.get(target, 'N/A')})")

    # --- Example 3: Single Node Graph ---
    print("\n--- Example 3: Single Node Graph ---")
    graph3 = Graph()
    graph3.add_node("OnlyNode")
    start_node3 = "OnlyNode"
    print(f"Graph nodes: {sorted(list(graph3.nodes))}")
    print(f"Starting Dijkstra from node: {start_node3}")
    distances3, predecessors3 = dijkstra(graph3, start_node3)
    print("\nShortest Distances from 'OnlyNode':")
    for node, dist in sorted(distances3.items()):
        print(f"  To {node}: {dist if dist != math.inf else 'Unreachable'}")
    
    path = reconstruct_path(predecessors3, start_node3, start_node3)
    if path:
        print(f"  Path to self: {' -> '.join(path)} (Distance: {distances3.get(start_node3, 'N/A')})")
    else:
        print(f"  Path to self: Failed to reconstruct path.")


    # --- Example 4: Error Handling ---
    print("\n--- Example 4: Error Handling ---")
    graph4 = Graph()
    graph4.add_edge("A", "B", 10)
    
    print("\nAttempting Dijkstra with a non-existent start node:")
    try:
        dijkstra(graph4, "Z")
    except ValueError as e:
        print(f"  Caught error: {e}")

    print("\nAttempting to add edge with negative weight:")
    try:
        graph4.add_edge("B", "C", -5)
    except ValueError as e:
        print(f"  Caught error: {e}")

    print("\nAttempting path reconstruction for a node not processed by Dijkstra:")
    predecessors_dummy = {'A': None, 'B': 'A'}
    path_fail = reconstruct_path(predecessors_dummy, 'A', 'Z')
    if path_fail is None:
        print(f"  Reconstruction for 'Z' returned None as expected.")

```